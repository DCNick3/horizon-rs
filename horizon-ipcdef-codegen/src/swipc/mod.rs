//! This implements a parser and a data model for (a variant of) [SwIPC](https://github.com/reswitched/SwIPC) files
//!
//! Notable changes:
//! - Replace most of the built-in types with atmosphere's abstractions
//!   so, buffer -> sf::*Buffer; pid -> sf::ClientProcessId; etc
//! - No more typed buffers, only bytes. Use either LargeData marker for the struct or an array
//!    So, no more `buffer<data_type, transfer_type, size>`
//! - Allow (and prefer) symbolic names for buffer transfer types
//! - do not put the placeholder u64 when sending our own PID using the kernel, it will be done automagically (see [here](https://discord.com/channels/269333940928512010/383368936466546698/994962645906108426))
//! - remote nn:: namespace prefix (we are not nintendo)
//! - use atmosphere's sf::Out markers for outputs, removing the `->` part altogether
//! - service names should be "in quotes"
//! - ???

use lalrpop_util::lalrpop_mod;

pub mod cli;
pub mod codegen;
pub mod diagnostics;
pub mod layout;
pub mod model;
mod typecheck;
pub mod util;

// include the code generated by larlpop parser generator
lalrpop_mod!(
    #[allow(clippy::all)]
    parser,
    "/swipc/swipc.rs"
);

#[cfg(test)]
mod tests {
    use crate::swipc::diagnostics::{diagnostics_and_files_from_parse_error, Span};
    use crate::swipc::model::{
        BufferTransferMode, IntType, Interface, NamespacedIdent, NominalType, Struct, StructField,
        TypeAlias, TypecheckedIpcFile,
    };
    use crate::swipc::parser;
    use codespan_reporting::diagnostic::Diagnostic;
    use codespan_reporting::term::termcolor::Buffer;
    use lalrpop_util::lexer::Token;
    use std::default::Default;
    use std::fmt::Debug;

    type ParseError<'a> = lalrpop_util::ParseError<usize, Token<'a>, Vec<Diagnostic<usize>>>;

    fn display_error(source: &str, error: ParseError) -> String {
        let (files, diagnostics) = diagnostics_and_files_from_parse_error(source, error);

        let mut writer = Buffer::ansi();
        let config = codespan_reporting::term::Config::default();

        for diag in diagnostics {
            codespan_reporting::term::emit(&mut writer, &config, &files, &diag).unwrap();
        }

        String::from_utf8(writer.into_inner()).expect("Non utf-8 error output...")
    }

    pub fn unwrap_parse<T>(source: &str, parser: impl FnOnce(&str) -> Result<T, ParseError>) -> T {
        match parser(source) {
            Ok(r) => r,
            Err(error) => {
                let err = display_error(source, error);
                panic!("{}", err);
            }
        }
    }

    fn unwrap_err_parse<T: Debug>(
        source: &str,
        parser: impl FnOnce(&str) -> Result<T, ParseError>,
        str_match: &str,
    ) {
        match parser(source) {
            Ok(r) => {
                panic!("Parse error should have occurred; parsed:\n{:#?}", r);
            }
            Err(error) => {
                let err = display_error(source, error);
                println!("{}", err);
                assert!(
                    err.contains(str_match),
                    "Could find the expected pattern in the error"
                );
            }
        }
    }

    fn parse_type_alias(s: &str) -> Result<TypeAlias, ParseError> {
        parser::TypeAliasParser::new().parse(0, s)
    }

    #[test]
    fn simple_type_alias() {
        let t: TypeAlias = unwrap_parse("type hello::world = u8;", parse_type_alias);
        assert_eq!(t.name, NamespacedIdent::parse("hello::world").unwrap());
        assert_eq!(t.referenced_type, NominalType::Int(IntType::U8));
    }

    #[test]
    fn name_type_alias() {
        let t: TypeAlias = unwrap_parse(r"type some_struct = some_other_struct;", parse_type_alias);
        assert_eq!(t.name, NamespacedIdent::parse("some_struct").unwrap());
        assert_eq!(
            t.referenced_type,
            NominalType::TypeName {
                name: NamespacedIdent::parse("some_other_struct").unwrap(),
                reference_location: Span::default(),
            },
        );
    }

    fn parse_struct_def(s: &str) -> Result<Struct, ParseError> {
        parser::StructDefParser::new().parse(0, s)
    }

    #[test]
    fn struct_def() {
        let t: Struct = unwrap_parse(
            r"
                struct some_struct {
                    u8 bla;
                    sf::Bytes<0x100> buffer;
                };",
            parse_struct_def,
        );
        assert_eq!(
            t,
            Struct {
                name: NamespacedIdent::parse("some_struct").unwrap(),
                is_large_data: false,
                preferred_transfer_mode: None,
                fields: vec![
                    StructField {
                        name: arcstr::literal!("bla"),
                        ty: NominalType::Int(IntType::U8),
                        location: Span::default(),
                    },
                    StructField {
                        name: arcstr::literal!("buffer"),
                        ty: NominalType::Bytes {
                            size: 0x100,
                            alignment: 0x1,
                        },
                        location: Span::default(),
                    },
                ],
                location: Span::default(),
            }
        );
    }

    #[test]
    fn struct_def_marked() {
        let t: Struct = unwrap_parse(
            r"
                struct some_struct : sf::LargeData, sf::PrefersPointerTransferMode {
                    u8 bla;
                    sf::Bytes<0x100> buffer;
                };",
            parse_struct_def,
        );
        assert_eq!(
            t,
            Struct {
                name: NamespacedIdent::parse("some_struct").unwrap(),
                is_large_data: true,
                preferred_transfer_mode: Some(BufferTransferMode::Pointer),
                fields: vec![
                    StructField {
                        name: arcstr::literal!("bla"),
                        ty: NominalType::Int(IntType::U8),
                        location: Span::default(),
                    },
                    StructField {
                        name: arcstr::literal!("buffer"),
                        ty: NominalType::Bytes {
                            size: 0x100,
                            alignment: 0x1,
                        },
                        location: Span::default(),
                    },
                ],
                location: Span::default(),
            }
        );
    }

    fn parse_interface(s: &str) -> Result<Interface, ParseError> {
        parser::InterfaceDefParser::new().parse(0, s)
    }

    #[test]
    fn idirectory_interface() {
        let s = r#"
interface fssrv::sf::IDirectory {
	/// Takes a type-0x6 output buffer. Returns an output u64(?) for the total
	/// number of read entries, this is 0 when no more entries are available.
	/// 
	/// The output buffer contains the read array of
	/// [\#DirectoryEntry](http://switchbrew.org/index.php?title=Filesystem%20services#DirectoryEntry "wikilink").
	/// This doesn't include entries for "." and "..".
	/// 
	[0] Read(sf::Out<s64> out, sf::OutBuffer out_entries);
	/// Returns an u64 for the total number of readable entries.
	/// 
	[1] GetEntryCount(sf::Out<s64> out);
}
        "#;
        let interface: Interface = unwrap_parse(s, parse_interface);

        println!("{:#?}", interface);
    }

    #[test]
    fn iuserinterface_interface() {
        let s = r#"
interface sm::detail::IUserInterface is "sm:" {
	/// Needs to be called before any other command may be used. On version 3.0.0
	/// and lower, if this function is not called, `GetService`, `RegisterService`
	/// and `UnregisterService` may be called without restriction, thanks to
	/// `sm:h`.
	///
	/// # Arguments
	/// - `reserved`:  Should be set to 0.
	[0] Initialize(sf::ClientProcessId);
	/// Returns a handle to the given service. IPC messages may be sent to this
	/// handle through `svcSendSyncRequest`.
	[1] GetService(ServiceName name, OutMoveHandle session_handle);
	/// Registers a service with the given name. The user can use
	/// `svcAcceptSession` on the returned handle to get a new Session handle, and
	/// use `svcReplyAndReceive` on those handles to reply to IPC requests.
	[2] RegisterService(ServiceName name, u8, u32 maxHandles, OutMoveHandle port_handle);
	/// Unregisters the given service. Future `GetService` call will not return
	/// this service anymore, but existing handles will stay alive.
	[3] UnregisterService(ServiceName name);
}
        "#;
        let interface: Interface = unwrap_parse(s, parse_interface);

        println!("{:#?}", interface);

        assert_eq!(
            interface.name,
            NamespacedIdent::parse("sm::detail::IUserInterface").unwrap()
        );
        assert_eq!(interface.sm_names, vec!["sm:"]);
    }

    pub fn parse_typechecked_ipc_file(s: &str) -> Result<TypecheckedIpcFile, ParseError> {
        parser::IpcFileParser::new()
            .parse(0, s)?
            .typecheck()
            .map_err(|error| ParseError::User { error })
    }

    #[test]
    fn multiple_def_file() {
        let s = r#"
type A = u8;
type B = u8;
type A = u8;
struct C {};
struct A {};
struct B {};
type C = A;
        "#;
        unwrap_err_parse(
            s,
            parse_typechecked_ipc_file,
            "Multiple definitions of type `A`",
        );
    }

    #[test]
    fn undef_alias_file() {
        let s = r#"
type T = undefined_type;
        "#;
        unwrap_err_parse(
            s,
            parse_typechecked_ipc_file,
            "Could not resolve type named `undefined_type`",
        );
    }

    #[test]
    fn undef_struct_file() {
        let s = r#"
struct S {
    undefined_type value;
};
        "#;
        unwrap_err_parse(
            s,
            parse_typechecked_ipc_file,
            "Could not resolve type named `undefined_type`",
        );
    }

    #[test]
    fn unsized_struct_file() {
        let s = r#"
struct Test {
    sf::Unknown<1> sized_value;
    sf::Unknown  unsized_value;
};
        "#;
        unwrap_err_parse(
            s,
            parse_typechecked_ipc_file,
            "Use of unsized type in field `unsized_value`",
        );
    }

    #[test]
    fn enum_overflow_file() {
        let s = r#"
enum Test : u8 {
    Ok1 = 1,
    Large = 256,
    Ok2 = 2,
};
        "#;
        unwrap_err_parse(
            s,
            parse_typechecked_ipc_file,
            "Value 256 of enum arm `Large` does not fit into type U8",
        );
    }

    #[test]
    fn enum_duplicate_val_file() {
        let s = r#"
enum Test : u8 {
    One1 = 1,
    One2 = 1,
    Two1 = 2,
    One3 = 1,
    Two2 = 2,
};
        "#;
        unwrap_err_parse(s, parse_typechecked_ipc_file, "Duplicate enum value");
    }

    #[test]
    fn enum_duplicate_name_file() {
        let s = r#"
enum Test : u8 {
    Name = 1,
    Name = 2,
};
        "#;
        unwrap_err_parse(
            s,
            parse_typechecked_ipc_file,
            "Duplicate enum arm named `Name`",
        );
    }

    #[test]
    fn struct_duplicate_file() {
        let s = r#"
struct Test {
    u8 one;
    u16 one;
};
        "#;
        unwrap_err_parse(
            s,
            parse_typechecked_ipc_file,
            "Duplicate struct field `one`",
        );
    }

    #[test]
    fn bitflags_overflow_file() {
        let s = r#"
bitflags Test : u8 {
    Ok1 = 1,
    Large = 256,
    Ok2 = 1,
};
        "#;
        unwrap_err_parse(
            s,
            parse_typechecked_ipc_file,
            "Value 256 of bitflags arm `Large` does not fit into type U8",
        );
    }

    #[test]
    fn bitflags_duplicate_file() {
        let s = r#"
bitflags Test : u8 {
    One = 1,
    One = 2,
};
        "#;
        unwrap_err_parse(
            s,
            parse_typechecked_ipc_file,
            "Duplicate bitfield arm named `One`",
        );
    }

    #[test]
    fn interface_duplicate_id_file() {
        let s = r#"
interface ITest {
    [1] Lol();
    [1] Kek();
}
        "#;
        unwrap_err_parse(
            s,
            parse_typechecked_ipc_file,
            "Duplicate command with id `1`",
        );
    }

    #[test]
    fn interface_duplicate_name_file() {
        let s = r#"
interface ITest {
    [1] Lol();
    [2] Lol();
}
        "#;
        unwrap_err_parse(
            s,
            parse_typechecked_ipc_file,
            "Duplicate command named `Lol`",
        );
    }

    #[test]
    fn interface_undef_type_file() {
        let s = r#"
interface ITest {
    [1] Lol(undefined_type hello);
}
        "#;
        unwrap_err_parse(
            s,
            parse_typechecked_ipc_file,
            "Could not resolve type named `undefined_type`",
        );
    }

    #[test]
    fn interface_undef_interface_file() {
        let s = r#"
interface ITest {
    [1] Lol(sf::SharedPointer<ISomeUndefinedInterface> hello);
}
        "#;
        unwrap_err_parse(
            s,
            parse_typechecked_ipc_file,
            "Could not resolve interface named `ISomeUndefinedInterface`",
        );
    }

    #[test]
    fn interface_file() {
        let s = r#"
interface ITest {
    [1] Lol(u8 hello, u16 world, u8 i, u32 am, u16 a, b8 test);
}
        "#;
        let file = unwrap_parse(s, parse_typechecked_ipc_file);

        println!("{:#?}", file);
    }

    #[test]
    fn struct_file() {
        let s = r#"
struct HelloStruct {
    u8 aaaa;
    u64 padded;
    u16 bbbb;
    u32 cccc;
};

type HelloStructAlias = HelloStruct;
        "#;
        let file = unwrap_parse(s, parse_typechecked_ipc_file);

        println!("{:#?}", file);
    }

    #[test]
    fn enum_naming() {
        let s = r#"
enum non_pascal_name : u8 {};
        "#;
        let file = unwrap_err_parse(s, parse_typechecked_ipc_file, "Enum name `non_pascal_name` should have the identifier in PascalCase, like `NonPascalName`");

        println!("{:#?}", file);
    }

    #[test]
    fn enum_arm_naming() {
        let s = r#"
enum PascalName : u8 {
    non_pascal_name = 1,
};
        "#;
        let file = unwrap_err_parse(
            s,
            parse_typechecked_ipc_file,
            "Enum arm name `non_pascal_name` should be in PascalCase, like `NonPascalName`",
        );

        println!("{:#?}", file);
    }

    #[test]
    fn type_alias_naming() {
        let s = r#"
type non_pascal_name = u8;
        "#;
        let file = unwrap_err_parse(s, parse_typechecked_ipc_file, "Type alias name `non_pascal_name` should have the identifier in PascalCase, like `NonPascalName`");

        println!("{:#?}", file);
    }

    #[test]
    fn struct_naming() {
        let s = r#"
struct lol::non_pascal_name {};
        "#;
        let file = unwrap_err_parse(s, parse_typechecked_ipc_file, "Struct name `lol::non_pascal_name` should have the identifier in PascalCase, like `lol::NonPascalName`");

        println!("{:#?}", file);
    }

    #[test]
    fn struct_field_naming() {
        let s = r#"
struct lol::PascalName {
    u8 PascalName;
};
        "#;
        let file = unwrap_err_parse(
            s,
            parse_typechecked_ipc_file,
            "Struct field name `PascalName` should be in snake_case, like `pascal_name`",
        );

        println!("{:#?}", file);
    }

    #[test]
    fn interface_naming() {
        let s = r#"
interface non_pascal_name {}
        "#;
        let file = unwrap_err_parse(s, parse_typechecked_ipc_file, "Interface name `non_pascal_name` should have the identifier in PascalCase, like `NonPascalName`");

        println!("{:#?}", file);
    }

    #[test]
    fn interface_namespace_naming() {
        let s = r#"
interface Kek::PascalName {}
        "#;
        let file = unwrap_err_parse(
            s,
            parse_typechecked_ipc_file,
            "Interface name `Kek::PascalName` should have namespaces in camel_case, like `kek::PascalName`",
        );

        println!("{:#?}", file);
    }

    #[test]
    fn command_naming() {
        let s = r#"
interface PascalName {
    [0] non_pascal_name();
}
        "#;
        let file = unwrap_err_parse(
            s,
            parse_typechecked_ipc_file,
            "Command name `non_pascal_name` should be in PascalCase, like `NonPascalName`",
        );

        println!("{:#?}", file);
    }

    #[test]
    fn command_argument_naming() {
        let s = r#"
interface PascalName {
    [0] PascalName(u8 PascalName);
}
        "#;
        let file = unwrap_err_parse(
            s,
            parse_typechecked_ipc_file,
            "Argument name `PascalName` should be in snake_case, like `pascal_name`",
        );

        println!("{:#?}", file);
    }
}
