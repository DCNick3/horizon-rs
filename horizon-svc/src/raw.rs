#![doc = r" Note: auto-generated file"]
#![doc = r" It is generated by horizon-svc-codegen by parsing the switchbrew wiki"]
#![allow(unused)]
#![allow(clippy::redundant_field_names)]
use core::arch::asm;
use horizon_error::ErrorCode;
pub struct SetHeapSizeResult {
    pub result: ErrorCode,
    pub heap_address: *const u8,
}
#[inline(always)]
#[must_use]
pub unsafe fn set_heap_size(size: u64) -> SetHeapSizeResult {
    let result: u32;
    let heap_address: *const u8;
    asm ! ("svc 0x01" , in ("x1") size , lateout ("w0") result , lateout ("x1") heap_address ,);
    SetHeapSizeResult {
        result: ErrorCode::new_unchecked(result),
        heap_address: heap_address,
    }
}
pub struct SetMemoryPermissionResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn set_memory_permission(
    address: *const u8,
    size: u64,
    memory_permission: u32,
) -> SetMemoryPermissionResult {
    let result: u32;
    asm ! ("svc 0x02" , in ("x0") address , in ("x1") size , in ("w2") memory_permission , lateout ("w0") result ,);
    SetMemoryPermissionResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct SetMemoryAttributeResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn set_memory_attribute(
    address: *const u8,
    size: u64,
    mask: u32,
    value: u32,
) -> SetMemoryAttributeResult {
    let result: u32;
    asm ! ("svc 0x03" , in ("x0") address , in ("x1") size , in ("w2") mask , in ("w3") value , lateout ("w0") result ,);
    SetMemoryAttributeResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct MapMemoryResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn map_memory(
    dst_address: *const u8,
    src_address: *const u8,
    size: u64,
) -> MapMemoryResult {
    let result: u32;
    asm ! ("svc 0x04" , in ("x0") dst_address , in ("x1") src_address , in ("x2") size , lateout ("w0") result ,);
    MapMemoryResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct UnmapMemoryResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn unmap_memory(
    dst_address: *const u8,
    src_address: *const u8,
    size: u64,
) -> UnmapMemoryResult {
    let result: u32;
    asm ! ("svc 0x05" , in ("x0") dst_address , in ("x1") src_address , in ("x2") size , lateout ("w0") result ,);
    UnmapMemoryResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct QueryMemoryResult {
    pub result: ErrorCode,
    pub page_info: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn query_memory(memory_info: u64, address: *const u8) -> QueryMemoryResult {
    let result: u32;
    let page_info: u32;
    asm ! ("svc 0x06" , in ("x0") memory_info , in ("x2") address , lateout ("w0") result , lateout ("w1") page_info ,);
    QueryMemoryResult {
        result: ErrorCode::new_unchecked(result),
        page_info: page_info,
    }
}
pub struct ExitProcessResult {}
#[inline(always)]
#[must_use]
pub unsafe fn exit_process() -> ExitProcessResult {
    asm!("svc 0x07",);
    ExitProcessResult {}
}
pub struct CreateThreadResult {
    pub result: ErrorCode,
    pub thread_handle: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn create_thread(
    entry: u64,
    thread_context: *const u8,
    stack_top: *const u8,
    priority: u32,
    processor_id: u32,
) -> CreateThreadResult {
    let result: u32;
    let thread_handle: u32;
    asm ! ("svc 0x08" , in ("x1") entry , in ("x2") thread_context , in ("x3") stack_top , in ("w4") priority , in ("w5") processor_id , lateout ("w0") result , lateout ("w1") thread_handle ,);
    CreateThreadResult {
        result: ErrorCode::new_unchecked(result),
        thread_handle: thread_handle,
    }
}
pub struct StartThreadResult {}
#[inline(always)]
#[must_use]
pub unsafe fn start_thread(thread_handle: u32) -> StartThreadResult {
    asm ! ("svc 0x09" , in ("w0") thread_handle ,);
    StartThreadResult {}
}
pub struct ExitThreadResult {}
#[inline(always)]
#[must_use]
pub unsafe fn exit_thread() -> ExitThreadResult {
    asm!("svc 0x0a",);
    ExitThreadResult {}
}
pub struct SleepThreadResult {}
#[inline(always)]
#[must_use]
pub unsafe fn sleep_thread(nanoseconds: u64) -> SleepThreadResult {
    asm ! ("svc 0x0b" , in ("x0") nanoseconds ,);
    SleepThreadResult {}
}
pub struct GetThreadPriorityResult {
    pub result: ErrorCode,
    pub priority: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_thread_priority(thread_handle: u32) -> GetThreadPriorityResult {
    let result: u32;
    let priority: u32;
    asm ! ("svc 0x0c" , in ("w1") thread_handle , lateout ("w0") result , lateout ("w1") priority ,);
    GetThreadPriorityResult {
        result: ErrorCode::new_unchecked(result),
        priority: priority,
    }
}
pub struct SetThreadPriorityResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn set_thread_priority(thread_handle: u32, priority: u32) -> SetThreadPriorityResult {
    let result: u32;
    asm ! ("svc 0x0d" , in ("w0") thread_handle , in ("w1") priority , lateout ("w0") result ,);
    SetThreadPriorityResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct GetThreadCoreMaskResult {
    pub result: ErrorCode,
    pub core_mask0: u32,
    pub core_mask1: u64,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_thread_core_mask(thread_handle: u32) -> GetThreadCoreMaskResult {
    let result: u32;
    let core_mask0: u32;
    let core_mask1: u64;
    asm ! ("svc 0x0e" , in ("w2") thread_handle , lateout ("w0") result , lateout ("w1") core_mask0 , lateout ("x2") core_mask1 ,);
    GetThreadCoreMaskResult {
        result: ErrorCode::new_unchecked(result),
        core_mask0: core_mask0,
        core_mask1: core_mask1,
    }
}
pub struct SetThreadCoreMaskResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn set_thread_core_mask(
    thread_handle: u32,
    core_mask0: u32,
    core_mask1: u64,
) -> SetThreadCoreMaskResult {
    let result: u32;
    asm ! ("svc 0x0f" , in ("w0") thread_handle , in ("w1") core_mask0 , in ("x2") core_mask1 , lateout ("w0") result ,);
    SetThreadCoreMaskResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct GetCurrentProcessorNumberResult {
    pub cpu_id: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_current_processor_number() -> GetCurrentProcessorNumberResult {
    let cpu_id: u32;
    asm ! ("svc 0x10" , lateout ("w0") cpu_id ,);
    GetCurrentProcessorNumberResult { cpu_id: cpu_id }
}
pub struct SignalEventResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn signal_event(event_handle: u32) -> SignalEventResult {
    let result: u32;
    asm ! ("svc 0x11" , in ("w0") event_handle , lateout ("x0") result ,);
    SignalEventResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct ClearEventResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn clear_event(event_handle: u32) -> ClearEventResult {
    let result: u32;
    asm ! ("svc 0x12" , in ("w0") event_handle , lateout ("x0") result ,);
    ClearEventResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct MapSharedMemoryResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn map_shared_memory(
    shared_memory_handle: u32,
    address: *const u8,
    size: u64,
    memory_permission: u32,
) -> MapSharedMemoryResult {
    let result: u32;
    asm ! ("svc 0x13" , in ("w0") shared_memory_handle , in ("x1") address , in ("x2") size , in ("w3") memory_permission , lateout ("w0") result ,);
    MapSharedMemoryResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct UnmapSharedMemoryResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn unmap_shared_memory(
    shared_memory_handle: u32,
    address: *const u8,
    size: u64,
) -> UnmapSharedMemoryResult {
    let result: u32;
    asm ! ("svc 0x14" , in ("w0") shared_memory_handle , in ("x1") address , in ("x2") size , lateout ("w0") result ,);
    UnmapSharedMemoryResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct CreateTransferMemoryResult {
    pub result: ErrorCode,
    pub transfer_memory_handle: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn create_transfer_memory(
    address: *const u8,
    size: u64,
    memory_permission: u32,
) -> CreateTransferMemoryResult {
    let result: u32;
    let transfer_memory_handle: u32;
    asm ! ("svc 0x15" , in ("x1") address , in ("x2") size , in ("w3") memory_permission , lateout ("w0") result , lateout ("w1") transfer_memory_handle ,);
    CreateTransferMemoryResult {
        result: ErrorCode::new_unchecked(result),
        transfer_memory_handle: transfer_memory_handle,
    }
}
pub struct CloseHandleResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn close_handle(handle: u32) -> CloseHandleResult {
    let result: u32;
    asm ! ("svc 0x16" , in ("w0") handle , lateout ("w0") result ,);
    CloseHandleResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct ResetSignalResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn reset_signal(handle: u32) -> ResetSignalResult {
    let result: u32;
    asm ! ("svc 0x17" , in ("w0") handle , lateout ("w0") result ,);
    ResetSignalResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct WaitSynchronizationResult {
    pub result: ErrorCode,
    pub handle_index: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn wait_synchronization(
    handles_ptr: *const u8,
    handles_num: u32,
    timeout: u64,
) -> WaitSynchronizationResult {
    let result: u32;
    let handle_index: u32;
    asm ! ("svc 0x18" , in ("x1") handles_ptr , in ("w2") handles_num , in ("x3") timeout , lateout ("w0") result , lateout ("w1") handle_index ,);
    WaitSynchronizationResult {
        result: ErrorCode::new_unchecked(result),
        handle_index: handle_index,
    }
}
pub struct CancelSynchronizationResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn cancel_synchronization(thread_handle: u32) -> CancelSynchronizationResult {
    let result: u32;
    asm ! ("svc 0x19" , in ("w0") thread_handle , lateout ("w0") result ,);
    CancelSynchronizationResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct ArbitrateLockResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn arbitrate_lock(
    thread_handle: u32,
    address: *const u8,
    tag: u32,
) -> ArbitrateLockResult {
    let result: u32;
    asm ! ("svc 0x1a" , in ("w0") thread_handle , in ("x1") address , in ("w2") tag , lateout ("w0") result ,);
    ArbitrateLockResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct ArbitrateUnlockResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn arbitrate_unlock(address: *const u8) -> ArbitrateUnlockResult {
    let result: u32;
    asm ! ("svc 0x1b" , in ("x0") address , lateout ("w0") result ,);
    ArbitrateUnlockResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct WaitProcessWideKeyAtomicResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn wait_process_wide_key_atomic(
    key_address: *const u8,
    tag_address: *const u8,
    tag: u32,
    timeout: u64,
) -> WaitProcessWideKeyAtomicResult {
    let result: u32;
    asm ! ("svc 0x1c" , in ("x0") key_address , in ("x1") tag_address , in ("w2") tag , in ("x3") timeout , lateout ("w0") result ,);
    WaitProcessWideKeyAtomicResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct SignalProcessWideKeyResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn signal_process_wide_key(
    address: *const u8,
    value: u32,
) -> SignalProcessWideKeyResult {
    let result: u32;
    asm ! ("svc 0x1d" , in ("x0") address , in ("w1") value , lateout ("w0") result ,);
    SignalProcessWideKeyResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct GetSystemTickResult {
    pub ticks: u64,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_system_tick() -> GetSystemTickResult {
    let ticks: u64;
    asm ! ("svc 0x1e" , lateout ("x0") ticks ,);
    GetSystemTickResult { ticks: ticks }
}
pub struct ConnectToNamedPortResult {
    pub result: ErrorCode,
    pub session_handle: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn connect_to_named_port(port_name: *const u8) -> ConnectToNamedPortResult {
    let result: u32;
    let session_handle: u32;
    asm ! ("svc 0x1f" , in ("x1") port_name , lateout ("w0") result , lateout ("w1") session_handle ,);
    ConnectToNamedPortResult {
        result: ErrorCode::new_unchecked(result),
        session_handle: session_handle,
    }
}
pub struct SendSyncRequestLightResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn send_sync_request_light(session_handle: u32) -> SendSyncRequestLightResult {
    let result: u32;
    asm ! ("svc 0x20" , in ("w0") session_handle , lateout ("w0") result ,);
    SendSyncRequestLightResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct SendSyncRequestResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn send_sync_request(session_handle: u32) -> SendSyncRequestResult {
    let result: u32;
    asm ! ("svc 0x21" , in ("w0") session_handle , lateout ("w0") result ,);
    SendSyncRequestResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct SendSyncRequestWithUserBufferResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn send_sync_request_with_user_buffer(
    address: *const u8,
    size: u64,
    session_handle: u32,
) -> SendSyncRequestWithUserBufferResult {
    let result: u32;
    asm ! ("svc 0x22" , in ("x0") address , in ("x1") size , in ("w2") session_handle , lateout ("w0") result ,);
    SendSyncRequestWithUserBufferResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct SendAsyncRequestWithUserBufferResult {
    pub result: ErrorCode,
    pub event_handle: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn send_async_request_with_user_buffer(
    address: *const u8,
    size: u64,
    session_handle: u32,
) -> SendAsyncRequestWithUserBufferResult {
    let result: u32;
    let event_handle: u32;
    asm ! ("svc 0x23" , in ("x1") address , in ("x2") size , in ("w3") session_handle , lateout ("w0") result , lateout ("w1") event_handle ,);
    SendAsyncRequestWithUserBufferResult {
        result: ErrorCode::new_unchecked(result),
        event_handle: event_handle,
    }
}
pub struct GetProcessIdResult {
    pub result: ErrorCode,
    pub process_id: u64,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_process_id(process_handle: u32) -> GetProcessIdResult {
    let result: u32;
    let process_id: u64;
    asm ! ("svc 0x24" , in ("w1") process_handle , lateout ("w0") result , lateout ("x1") process_id ,);
    GetProcessIdResult {
        result: ErrorCode::new_unchecked(result),
        process_id: process_id,
    }
}
pub struct GetThreadIdResult {
    pub result: ErrorCode,
    pub thread_id: u64,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_thread_id(thread_handle: u32) -> GetThreadIdResult {
    let result: u32;
    let thread_id: u64;
    asm ! ("svc 0x25" , in ("w1") thread_handle , lateout ("w0") result , lateout ("x1") thread_id ,);
    GetThreadIdResult {
        result: ErrorCode::new_unchecked(result),
        thread_id: thread_id,
    }
}
pub struct BreakResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn r#break(break_reason: u64, unnamed_2: u64, info: u64) -> BreakResult {
    let result: u32;
    asm ! ("svc 0x26" , in ("x0") break_reason , in ("x1") unnamed_2 , in ("x2") info , lateout ("w0") result ,);
    BreakResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct OutputDebugStringResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn output_debug_string(string: *const u8, size: u64) -> OutputDebugStringResult {
    let result: u32;
    asm ! ("svc 0x27" , in ("x0") string , in ("x1") size , lateout ("w0") result ,);
    OutputDebugStringResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct ReturnFromExceptionResult {}
#[inline(always)]
#[must_use]
pub unsafe fn return_from_exception(result: ErrorCode) -> ReturnFromExceptionResult {
    asm ! ("svc 0x28" , in ("w0") result . repr () ,);
    ReturnFromExceptionResult {}
}
pub struct GetInfoResult {
    pub result: ErrorCode,
    pub info: u64,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_info(info_type: u32, handle: u32, info_sub_type: u64) -> GetInfoResult {
    let result: u32;
    let info: u64;
    asm ! ("svc 0x29" , in ("w1") info_type , in ("w2") handle , in ("x3") info_sub_type , lateout ("w0") result , lateout ("x1") info ,);
    GetInfoResult {
        result: ErrorCode::new_unchecked(result),
        info: info,
    }
}
pub struct FlushEntireDataCacheResult {}
#[inline(always)]
#[must_use]
pub unsafe fn flush_entire_data_cache() -> FlushEntireDataCacheResult {
    asm!("svc 0x2a",);
    FlushEntireDataCacheResult {}
}
pub struct FlushDataCacheResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn flush_data_cache(address: *const u8, size: u64) -> FlushDataCacheResult {
    let result: u32;
    asm ! ("svc 0x2b" , in ("x0") address , in ("x1") size , lateout ("w0") result ,);
    FlushDataCacheResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct MapPhysicalMemoryResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn map_physical_memory(address: *const u8, size: u64) -> MapPhysicalMemoryResult {
    let result: u32;
    asm ! ("svc 0x2c" , in ("x0") address , in ("x1") size , lateout ("w0") result ,);
    MapPhysicalMemoryResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct UnmapPhysicalMemoryResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn unmap_physical_memory(address: *const u8, size: u64) -> UnmapPhysicalMemoryResult {
    let result: u32;
    asm ! ("svc 0x2d" , in ("x0") address , in ("x1") size , lateout ("w0") result ,);
    UnmapPhysicalMemoryResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct GetDebugFutureThreadInfoResult {
    pub result: ErrorCode,
    pub unnamed_3: u64,
    pub unnamed_4: u64,
    pub unnamed_5: u64,
    pub unnamed_6: u64,
    pub unnamed_7: u64,
    pub unnamed_8: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_debug_future_thread_info(timeout: u64) -> GetDebugFutureThreadInfoResult {
    let result: u32;
    let unnamed_3: u64;
    let unnamed_4: u64;
    let unnamed_5: u64;
    let unnamed_6: u64;
    let unnamed_7: u64;
    let unnamed_8: u32;
    asm ! ("svc 0x2e" , in ("x3") timeout , lateout ("w0") result , lateout ("x1") unnamed_3 , lateout ("x2") unnamed_4 , lateout ("x3") unnamed_5 , lateout ("x4") unnamed_6 , lateout ("x5") unnamed_7 , lateout ("w6") unnamed_8 ,);
    GetDebugFutureThreadInfoResult {
        result: ErrorCode::new_unchecked(result),
        unnamed_3: unnamed_3,
        unnamed_4: unnamed_4,
        unnamed_5: unnamed_5,
        unnamed_6: unnamed_6,
        unnamed_7: unnamed_7,
        unnamed_8: unnamed_8,
    }
}
pub struct GetLastThreadInfoResult {
    pub result: ErrorCode,
    pub last_thread_context_param0: u64,
    pub last_thread_context_param1: u64,
    pub last_thread_context_param2: u64,
    pub last_thread_context_param3: u64,
    pub unnamed_7: u64,
    pub unnamed_8: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_last_thread_info() -> GetLastThreadInfoResult {
    let result: u32;
    let last_thread_context_param0: u64;
    let last_thread_context_param1: u64;
    let last_thread_context_param2: u64;
    let last_thread_context_param3: u64;
    let unnamed_7: u64;
    let unnamed_8: u32;
    asm ! ("svc 0x2f" , lateout ("w0") result , lateout ("x1") last_thread_context_param0 , lateout ("x2") last_thread_context_param1 , lateout ("x3") last_thread_context_param2 , lateout ("x4") last_thread_context_param3 , lateout ("x5") unnamed_7 , lateout ("w6") unnamed_8 ,);
    GetLastThreadInfoResult {
        result: ErrorCode::new_unchecked(result),
        last_thread_context_param0: last_thread_context_param0,
        last_thread_context_param1: last_thread_context_param1,
        last_thread_context_param2: last_thread_context_param2,
        last_thread_context_param3: last_thread_context_param3,
        unnamed_7: unnamed_7,
        unnamed_8: unnamed_8,
    }
}
pub struct GetResourceLimitLimitValueResult {
    pub result: ErrorCode,
    pub limit_value: u64,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_resource_limit_limit_value(
    resource_limit_handle: u32,
    limitable_resource: u32,
) -> GetResourceLimitLimitValueResult {
    let result: u32;
    let limit_value: u64;
    asm ! ("svc 0x30" , in ("w1") resource_limit_handle , in ("w2") limitable_resource , lateout ("w0") result , lateout ("x1") limit_value ,);
    GetResourceLimitLimitValueResult {
        result: ErrorCode::new_unchecked(result),
        limit_value: limit_value,
    }
}
pub struct GetResourceLimitCurrentValueResult {
    pub result: ErrorCode,
    pub current_value: u64,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_resource_limit_current_value(
    resource_limit_handle: u32,
    limitable_resource: u32,
) -> GetResourceLimitCurrentValueResult {
    let result: u32;
    let current_value: u64;
    asm ! ("svc 0x31" , in ("w1") resource_limit_handle , in ("w2") limitable_resource , lateout ("w0") result , lateout ("x1") current_value ,);
    GetResourceLimitCurrentValueResult {
        result: ErrorCode::new_unchecked(result),
        current_value: current_value,
    }
}
pub struct SetThreadActivityResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn set_thread_activity(
    thread_handle: u32,
    thread_activity: u32,
) -> SetThreadActivityResult {
    let result: u32;
    asm ! ("svc 0x32" , in ("w0") thread_handle , in ("w1") thread_activity , lateout ("w0") result ,);
    SetThreadActivityResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct GetThreadContext3Result {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_thread_context3(
    thread_context: u64,
    thread_handle: u32,
) -> GetThreadContext3Result {
    let result: u32;
    asm ! ("svc 0x33" , in ("x0") thread_context , in ("w1") thread_handle , lateout ("w0") result ,);
    GetThreadContext3Result {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct WaitForAddressResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn wait_for_address(
    address: *const u8,
    arbitration_type: u32,
    value: u32,
    timeout: u64,
) -> WaitForAddressResult {
    let result: u32;
    asm ! ("svc 0x34" , in ("x0") address , in ("w1") arbitration_type , in ("w2") value , in ("x3") timeout , lateout ("w0") result ,);
    WaitForAddressResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct SignalToAddressResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn signal_to_address(
    address: *const u8,
    signal_type: u32,
    value: u32,
    num_to_signal: u32,
) -> SignalToAddressResult {
    let result: u32;
    asm ! ("svc 0x35" , in ("x0") address , in ("w1") signal_type , in ("w2") value , in ("w3") num_to_signal , lateout ("w0") result ,);
    SignalToAddressResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct SynchronizePreemptionStateResult {}
#[inline(always)]
#[must_use]
pub unsafe fn synchronize_preemption_state() -> SynchronizePreemptionStateResult {
    asm!("svc 0x36",);
    SynchronizePreemptionStateResult {}
}
pub struct GetResourceLimitPeakValueResult {
    pub result: ErrorCode,
    pub peak_value: u64,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_resource_limit_peak_value(
    resource_limit_handle: u32,
    limitable_resource: u32,
) -> GetResourceLimitPeakValueResult {
    let result: u32;
    let peak_value: u64;
    asm ! ("svc 0x37" , in ("w1") resource_limit_handle , in ("w2") limitable_resource , lateout ("w0") result , lateout ("x1") peak_value ,);
    GetResourceLimitPeakValueResult {
        result: ErrorCode::new_unchecked(result),
        peak_value: peak_value,
    }
}
pub struct DumpInfoResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn dump_info(dump_info_type: u64, dump_info_sub_type: u64) -> DumpInfoResult {
    let result: u32;
    asm ! ("svc 0x3c" , in ("x0") dump_info_type , in ("x1") dump_info_sub_type , lateout ("w0") result ,);
    DumpInfoResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct KernelDebugResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn kernel_debug(
    kernel_debug_type: u32,
    unnamed_2: u64,
    unnamed_3: u64,
    unnamed_4: u64,
) -> KernelDebugResult {
    let result: u32;
    asm ! ("svc 0x3c" , in ("w0") kernel_debug_type , in ("x1") unnamed_2 , in ("x2") unnamed_3 , in ("x3") unnamed_4 , lateout ("w0") result ,);
    KernelDebugResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct ChangeKernelTraceStateResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn change_kernel_trace_state(kernel_trace_state: u32) -> ChangeKernelTraceStateResult {
    let result: u32;
    asm ! ("svc 0x3d" , in ("w0") kernel_trace_state , lateout ("w0") result ,);
    ChangeKernelTraceStateResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct CreateSessionResult {
    pub result: ErrorCode,
    pub server_session_handle: u32,
    pub client_session_handle: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn create_session(is_light: u32, name: u64) -> CreateSessionResult {
    let result: u32;
    let server_session_handle: u32;
    let client_session_handle: u32;
    asm ! ("svc 0x40" , in ("w2") is_light , in ("x3") name , lateout ("w0") result , lateout ("w1") server_session_handle , lateout ("w2") client_session_handle ,);
    CreateSessionResult {
        result: ErrorCode::new_unchecked(result),
        server_session_handle: server_session_handle,
        client_session_handle: client_session_handle,
    }
}
pub struct AcceptSessionResult {
    pub result: ErrorCode,
    pub server_session_handle: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn accept_session(port_handle: u32) -> AcceptSessionResult {
    let result: u32;
    let server_session_handle: u32;
    asm ! ("svc 0x41" , in ("w1") port_handle , lateout ("w0") result , lateout ("w1") server_session_handle ,);
    AcceptSessionResult {
        result: ErrorCode::new_unchecked(result),
        server_session_handle: server_session_handle,
    }
}
pub struct ReplyAndReceiveLightResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn reply_and_receive_light(handle: u32) -> ReplyAndReceiveLightResult {
    let result: u32;
    asm ! ("svc 0x42" , in ("w0") handle , lateout ("w0") result ,);
    ReplyAndReceiveLightResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct ReplyAndReceiveResult {
    pub result: ErrorCode,
    pub handle_index: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn reply_and_receive(
    handles: *const u8,
    num_handles: u32,
    reply_target_session_handle: u32,
    timeout: u64,
) -> ReplyAndReceiveResult {
    let result: u32;
    let handle_index: u32;
    asm ! ("svc 0x43" , in ("x1") handles , in ("w2") num_handles , in ("w3") reply_target_session_handle , in ("x4") timeout , lateout ("w0") result , lateout ("w1") handle_index ,);
    ReplyAndReceiveResult {
        result: ErrorCode::new_unchecked(result),
        handle_index: handle_index,
    }
}
pub struct ReplyAndReceiveWithUserBufferResult {
    pub result: ErrorCode,
    pub handle_index: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn reply_and_receive_with_user_buffer(
    address: *const u8,
    size: u64,
    handles: *const u8,
    num_handles: u32,
    reply_target_session_handle: u32,
    timeout: u64,
) -> ReplyAndReceiveWithUserBufferResult {
    let result: u32;
    let handle_index: u32;
    asm ! ("svc 0x44" , in ("x1") address , in ("x2") size , in ("x3") handles , in ("w4") num_handles , in ("w5") reply_target_session_handle , in ("x6") timeout , lateout ("w0") result , lateout ("w1") handle_index ,);
    ReplyAndReceiveWithUserBufferResult {
        result: ErrorCode::new_unchecked(result),
        handle_index: handle_index,
    }
}
pub struct CreateEventResult {
    pub result: ErrorCode,
    pub writable_event_handle: u32,
    pub readable_event_handle: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn create_event() -> CreateEventResult {
    let result: u32;
    let writable_event_handle: u32;
    let readable_event_handle: u32;
    asm ! ("svc 0x45" , lateout ("w0") result , lateout ("w1") writable_event_handle , lateout ("w2") readable_event_handle ,);
    CreateEventResult {
        result: ErrorCode::new_unchecked(result),
        writable_event_handle: writable_event_handle,
        readable_event_handle: readable_event_handle,
    }
}
pub struct MapPhysicalMemoryUnsafeResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn map_physical_memory_unsafe(
    address: *const u8,
    size: u64,
) -> MapPhysicalMemoryUnsafeResult {
    let result: u32;
    asm ! ("svc 0x48" , in ("x0") address , in ("x1") size , lateout ("w0") result ,);
    MapPhysicalMemoryUnsafeResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct UnmapPhysicalMemoryUnsafeResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn unmap_physical_memory_unsafe(
    address: *const u8,
    size: u64,
) -> UnmapPhysicalMemoryUnsafeResult {
    let result: u32;
    asm ! ("svc 0x49" , in ("x0") address , in ("x1") size , lateout ("w0") result ,);
    UnmapPhysicalMemoryUnsafeResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct SetUnsafeLimitResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn set_unsafe_limit(limit: u64) -> SetUnsafeLimitResult {
    let result: u32;
    asm ! ("svc 0x4a" , in ("x0") limit , lateout ("w0") result ,);
    SetUnsafeLimitResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct CreateCodeMemoryResult {
    pub result: ErrorCode,
    pub code_memory_handle: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn create_code_memory(address: *const u8, size: u64) -> CreateCodeMemoryResult {
    let result: u32;
    let code_memory_handle: u32;
    asm ! ("svc 0x4b" , in ("x1") address , in ("x2") size , lateout ("w0") result , lateout ("w1") code_memory_handle ,);
    CreateCodeMemoryResult {
        result: ErrorCode::new_unchecked(result),
        code_memory_handle: code_memory_handle,
    }
}
pub struct ControlCodeMemoryResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn control_code_memory(
    code_memory_handle: u32,
    code_memory_operation: u32,
    address: *const u8,
    size: u64,
    memory_permission: u32,
) -> ControlCodeMemoryResult {
    let result: u32;
    asm ! ("svc 0x4c" , in ("w0") code_memory_handle , in ("w1") code_memory_operation , in ("x2") address , in ("x3") size , in ("w4") memory_permission , lateout ("w0") result ,);
    ControlCodeMemoryResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct SleepSystemResult {}
#[inline(always)]
#[must_use]
pub unsafe fn sleep_system() -> SleepSystemResult {
    asm!("svc 0x4d",);
    SleepSystemResult {}
}
pub struct ReadWriteRegisterResult {
    pub result: ErrorCode,
    pub out_value: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn read_write_register(
    register_address: u64,
    rw_mask: u32,
    in_value: u32,
) -> ReadWriteRegisterResult {
    let result: u32;
    let out_value: u32;
    asm ! ("svc 0x4e" , in ("x1") register_address , in ("w2") rw_mask , in ("w3") in_value , lateout ("w0") result , lateout ("w1") out_value ,);
    ReadWriteRegisterResult {
        result: ErrorCode::new_unchecked(result),
        out_value: out_value,
    }
}
pub struct SetProcessActivityResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn set_process_activity(
    process_handle: u32,
    process_activity: u32,
) -> SetProcessActivityResult {
    let result: u32;
    asm ! ("svc 0x4f" , in ("w0") process_handle , in ("w1") process_activity , lateout ("w0") result ,);
    SetProcessActivityResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct CreateSharedMemoryResult {
    pub result: ErrorCode,
    pub shared_memory_handle: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn create_shared_memory(
    size: u32,
    local_memory_permission: u32,
    remote_memory_permission: u32,
) -> CreateSharedMemoryResult {
    let result: u32;
    let shared_memory_handle: u32;
    asm ! ("svc 0x50" , in ("w1") size , in ("w2") local_memory_permission , in ("w3") remote_memory_permission , lateout ("w0") result , lateout ("w1") shared_memory_handle ,);
    CreateSharedMemoryResult {
        result: ErrorCode::new_unchecked(result),
        shared_memory_handle: shared_memory_handle,
    }
}
pub struct MapTransferMemoryResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn map_transfer_memory(
    transfer_memory_handle: u64,
    address: *const u8,
    size: u64,
    memory_permission: u32,
) -> MapTransferMemoryResult {
    let result: u32;
    asm ! ("svc 0x51" , in ("x0") transfer_memory_handle , in ("x1") address , in ("x2") size , in ("w3") memory_permission , lateout ("w0") result ,);
    MapTransferMemoryResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct UnmapTransferMemoryResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn unmap_transfer_memory(
    transfer_memory_handle: u64,
    address: *const u8,
    size: u64,
) -> UnmapTransferMemoryResult {
    let result: u32;
    asm ! ("svc 0x52" , in ("x0") transfer_memory_handle , in ("x1") address , in ("x2") size , lateout ("w0") result ,);
    UnmapTransferMemoryResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct CreateInterruptEventResult {
    pub result: ErrorCode,
    pub readable_event_handle: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn create_interrupt_event(
    interrupt: u64,
    interrupt_type: u32,
) -> CreateInterruptEventResult {
    let result: u32;
    let readable_event_handle: u32;
    asm ! ("svc 0x53" , in ("x1") interrupt , in ("w2") interrupt_type , lateout ("w0") result , lateout ("w1") readable_event_handle ,);
    CreateInterruptEventResult {
        result: ErrorCode::new_unchecked(result),
        readable_event_handle: readable_event_handle,
    }
}
pub struct QueryPhysicalAddressResult {
    pub result: ErrorCode,
    pub physical_memory_info_address: u64,
    pub physical_memory_info_base_address: u64,
    pub physical_memory_info_size: u64,
}
#[inline(always)]
#[must_use]
pub unsafe fn query_physical_address(virtual_address: *const u8) -> QueryPhysicalAddressResult {
    let result: u32;
    let physical_memory_info_address: u64;
    let physical_memory_info_base_address: u64;
    let physical_memory_info_size: u64;
    asm ! ("svc 0x54" , in ("x1") virtual_address , lateout ("w0") result , lateout ("x1") physical_memory_info_address , lateout ("x2") physical_memory_info_base_address , lateout ("x3") physical_memory_info_size ,);
    QueryPhysicalAddressResult {
        result: ErrorCode::new_unchecked(result),
        physical_memory_info_address: physical_memory_info_address,
        physical_memory_info_base_address: physical_memory_info_base_address,
        physical_memory_info_size: physical_memory_info_size,
    }
}
pub struct QueryIoMappingResult {
    pub result: ErrorCode,
    pub virtual_address: *const u8,
}
#[inline(always)]
#[must_use]
pub unsafe fn query_io_mapping(io_address: u64, size: u64) -> QueryIoMappingResult {
    let result: u32;
    let virtual_address: *const u8;
    asm ! ("svc 0x55" , in ("x1") io_address , in ("x2") size , lateout ("w0") result , lateout ("x1") virtual_address ,);
    QueryIoMappingResult {
        result: ErrorCode::new_unchecked(result),
        virtual_address: virtual_address,
    }
}
pub struct CreateDeviceAddressSpaceResult {
    pub result: ErrorCode,
    pub device_address_space_handle: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn create_device_address_space(
    device_address_space_start_address: u64,
    device_address_space_end_address: u64,
) -> CreateDeviceAddressSpaceResult {
    let result: u32;
    let device_address_space_handle: u32;
    asm ! ("svc 0x56" , in ("x1") device_address_space_start_address , in ("x2") device_address_space_end_address , lateout ("w0") result , lateout ("w1") device_address_space_handle ,);
    CreateDeviceAddressSpaceResult {
        result: ErrorCode::new_unchecked(result),
        device_address_space_handle: device_address_space_handle,
    }
}
pub struct AttachDeviceAddressSpaceResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn attach_device_address_space(
    device_name: u32,
    device_address_space_handle: u64,
) -> AttachDeviceAddressSpaceResult {
    let result: u32;
    asm ! ("svc 0x57" , in ("w0") device_name , in ("x1") device_address_space_handle , lateout ("w0") result ,);
    AttachDeviceAddressSpaceResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct DetachDeviceAddressSpaceResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn detach_device_address_space(
    device_name: u32,
    device_address_space_handle: u64,
) -> DetachDeviceAddressSpaceResult {
    let result: u32;
    asm ! ("svc 0x58" , in ("w0") device_name , in ("x1") device_address_space_handle , lateout ("w0") result ,);
    DetachDeviceAddressSpaceResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct MapDeviceAddressSpaceByForceResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn map_device_address_space_by_force(
    device_address_space_handle: u32,
    process_handle: u32,
    address: *const u8,
    device_address_space_size: u64,
    device_address_space_address: u64,
    memory_permission: u32,
) -> MapDeviceAddressSpaceByForceResult {
    let result: u32;
    asm ! ("svc 0x59" , in ("w0") device_address_space_handle , in ("w1") process_handle , in ("x2") address , in ("x3") device_address_space_size , in ("x4") device_address_space_address , in ("w5") memory_permission , lateout ("w0") result ,);
    MapDeviceAddressSpaceByForceResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct MapDeviceAddressSpaceAlignedResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn map_device_address_space_aligned(
    device_address_space_handle: u32,
    process_handle: u32,
    address: *const u8,
    device_address_space_size: u64,
    device_address_space_address: u64,
    memory_permission: u32,
) -> MapDeviceAddressSpaceAlignedResult {
    let result: u32;
    asm ! ("svc 0x5a" , in ("w0") device_address_space_handle , in ("w1") process_handle , in ("x2") address , in ("x3") device_address_space_size , in ("x4") device_address_space_address , in ("w5") memory_permission , lateout ("w0") result ,);
    MapDeviceAddressSpaceAlignedResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct MapDeviceAddressSpaceResult {
    pub result: ErrorCode,
    pub size: u64,
}
#[inline(always)]
#[must_use]
pub unsafe fn map_device_address_space(
    device_address_space_handle: u32,
    process_handle: u32,
    address: *const u8,
    device_address_space_size: u64,
    device_address_space_address: u64,
    memory_permission: u32,
) -> MapDeviceAddressSpaceResult {
    let result: u32;
    let size: u64;
    asm ! ("svc 0x5b" , in ("w1") device_address_space_handle , in ("w2") process_handle , in ("x3") address , in ("x4") device_address_space_size , in ("x5") device_address_space_address , in ("w6") memory_permission , lateout ("w0") result , lateout ("x1") size ,);
    MapDeviceAddressSpaceResult {
        result: ErrorCode::new_unchecked(result),
        size: size,
    }
}
pub struct UnmapDeviceAddressSpaceResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn unmap_device_address_space(
    device_address_space_handle: u32,
    process_handle: u32,
    address: *const u8,
    device_address_space_size: u64,
    device_address_space_address: u64,
) -> UnmapDeviceAddressSpaceResult {
    let result: u32;
    asm ! ("svc 0x5c" , in ("w0") device_address_space_handle , in ("w1") process_handle , in ("x2") address , in ("x3") device_address_space_size , in ("x4") device_address_space_address , lateout ("w0") result ,);
    UnmapDeviceAddressSpaceResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct InvalidateProcessDataCacheResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn invalidate_process_data_cache(
    process_handle: u32,
    address: *const u8,
    size: u64,
) -> InvalidateProcessDataCacheResult {
    let result: u32;
    asm ! ("svc 0x5d" , in ("w0") process_handle , in ("x1") address , in ("x2") size , lateout ("w0") result ,);
    InvalidateProcessDataCacheResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct StoreProcessDataCacheResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn store_process_data_cache(
    process_handle: u32,
    address: *const u8,
    size: u64,
) -> StoreProcessDataCacheResult {
    let result: u32;
    asm ! ("svc 0x5e" , in ("w0") process_handle , in ("x1") address , in ("x2") size , lateout ("w0") result ,);
    StoreProcessDataCacheResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct FlushProcessDataCacheResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn flush_process_data_cache(
    process_handle: u32,
    address: *const u8,
    size: u64,
) -> FlushProcessDataCacheResult {
    let result: u32;
    asm ! ("svc 0x5f" , in ("w0") process_handle , in ("x1") address , in ("x2") size , lateout ("w0") result ,);
    FlushProcessDataCacheResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct DebugActiveProcessResult {
    pub result: ErrorCode,
    pub debug_handle: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn debug_active_process(process_id: u64) -> DebugActiveProcessResult {
    let result: u32;
    let debug_handle: u32;
    asm ! ("svc 0x60" , in ("x1") process_id , lateout ("w0") result , lateout ("w1") debug_handle ,);
    DebugActiveProcessResult {
        result: ErrorCode::new_unchecked(result),
        debug_handle: debug_handle,
    }
}
pub struct BreakDebugProcessResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn break_debug_process(debug_handle: u32) -> BreakDebugProcessResult {
    let result: u32;
    asm ! ("svc 0x61" , in ("w0") debug_handle , lateout ("w0") result ,);
    BreakDebugProcessResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct TerminateDebugProcessResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn terminate_debug_process(debug_handle: u32) -> TerminateDebugProcessResult {
    let result: u32;
    asm ! ("svc 0x62" , in ("w0") debug_handle , lateout ("w0") result ,);
    TerminateDebugProcessResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct GetDebugEventResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_debug_event(debug_event_info: u64, debug_handle: u32) -> GetDebugEventResult {
    let result: u32;
    asm ! ("svc 0x63" , in ("x0") debug_event_info , in ("w1") debug_handle , lateout ("w0") result ,);
    GetDebugEventResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct GetProcessListResult {
    pub result: ErrorCode,
    pub num_processes: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_process_list(
    process_id_buffer: *const u8,
    process_id_buffer_size: u32,
) -> GetProcessListResult {
    let result: u32;
    let num_processes: u32;
    asm ! ("svc 0x65" , in ("x1") process_id_buffer , in ("w2") process_id_buffer_size , lateout ("x0") result , lateout ("w1") num_processes ,);
    GetProcessListResult {
        result: ErrorCode::new_unchecked(result),
        num_processes: num_processes,
    }
}
pub struct GetThreadListResult {
    pub result: ErrorCode,
    pub num_threads: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_thread_list(
    thread_id_buffer: *const u8,
    thread_id_buffer_size: u32,
    debug_handle: u32,
) -> GetThreadListResult {
    let result: u32;
    let num_threads: u32;
    asm ! ("svc 0x66" , in ("x1") thread_id_buffer , in ("w2") thread_id_buffer_size , in ("w3") debug_handle , lateout ("x0") result , lateout ("w1") num_threads ,);
    GetThreadListResult {
        result: ErrorCode::new_unchecked(result),
        num_threads: num_threads,
    }
}
pub struct GetDebugThreadContextResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_debug_thread_context(
    thread_context: u64,
    debug_handle: u64,
    thread_id: u64,
    a_href_thread_context_flags_thread_context_flags_a: u32,
) -> GetDebugThreadContextResult {
    let result: u32;
    asm ! ("svc 0x67" , in ("x0") thread_context , in ("x1") debug_handle , in ("x2") thread_id , in ("w3") a_href_thread_context_flags_thread_context_flags_a , lateout ("w0") result ,);
    GetDebugThreadContextResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct SetDebugThreadContextResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn set_debug_thread_context(
    debug_handle: u32,
    thread_id: u64,
    thread_context: u64,
    a_href_thread_context_flags_thread_context_flags_a: u32,
) -> SetDebugThreadContextResult {
    let result: u32;
    asm ! ("svc 0x68" , in ("w0") debug_handle , in ("x1") thread_id , in ("x2") thread_context , in ("w3") a_href_thread_context_flags_thread_context_flags_a , lateout ("w0") result ,);
    SetDebugThreadContextResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct QueryDebugProcessMemoryResult {
    pub result: ErrorCode,
    pub page_info: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn query_debug_process_memory(
    memory_info: u64,
    debug_handle: u32,
    address: *const u8,
) -> QueryDebugProcessMemoryResult {
    let result: u32;
    let page_info: u32;
    asm ! ("svc 0x69" , in ("x0") memory_info , in ("w2") debug_handle , in ("x3") address , lateout ("w0") result , lateout ("w1") page_info ,);
    QueryDebugProcessMemoryResult {
        result: ErrorCode::new_unchecked(result),
        page_info: page_info,
    }
}
pub struct ReadDebugProcessMemoryResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn read_debug_process_memory(
    memory_buffer_address: *const u8,
    debug_handle: u32,
    src_address: *const u8,
    size: u64,
) -> ReadDebugProcessMemoryResult {
    let result: u32;
    asm ! ("svc 0x6a" , in ("x0") memory_buffer_address , in ("w1") debug_handle , in ("x2") src_address , in ("x3") size , lateout ("w0") result ,);
    ReadDebugProcessMemoryResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct WriteDebugProcessMemoryResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn write_debug_process_memory(
    debug_handle: u32,
    memory_buffer_address: *const u8,
    dst_address: *const u8,
    size: u64,
) -> WriteDebugProcessMemoryResult {
    let result: u32;
    asm ! ("svc 0x6b" , in ("w0") debug_handle , in ("x1") memory_buffer_address , in ("x2") dst_address , in ("x3") size , lateout ("w0") result ,);
    WriteDebugProcessMemoryResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct SetHardwareBreakPointResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn set_hardware_break_point(
    name: u32,
    flags: u64,
    value: u64,
) -> SetHardwareBreakPointResult {
    let result: u32;
    asm ! ("svc 0x6c" , in ("w0") name , in ("x1") flags , in ("x2") value , lateout ("w0") result ,);
    SetHardwareBreakPointResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct GetDebugThreadParamResult {
    pub result: ErrorCode,
    pub out0: u64,
    pub out1: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_debug_thread_param(
    debug_handle: u64,
    thread_id: u64,
    debug_thread_param: u32,
) -> GetDebugThreadParamResult {
    let result: u32;
    let out0: u64;
    let out1: u32;
    asm ! ("svc 0x6d" , in ("x2") debug_handle , in ("x3") thread_id , in ("w4") debug_thread_param , lateout ("w0") result , lateout ("x1") out0 , lateout ("w2") out1 ,);
    GetDebugThreadParamResult {
        result: ErrorCode::new_unchecked(result),
        out0: out0,
        out1: out1,
    }
}
pub struct GetSystemInfoResult {
    pub result: ErrorCode,
    pub system_info: u64,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_system_info(
    system_info_type: u64,
    handle: u32,
    system_info_sub_type: u64,
) -> GetSystemInfoResult {
    let result: u32;
    let system_info: u64;
    asm ! ("svc 0x6f" , in ("x1") system_info_type , in ("w2") handle , in ("x3") system_info_sub_type , lateout ("w0") result , lateout ("x1") system_info ,);
    GetSystemInfoResult {
        result: ErrorCode::new_unchecked(result),
        system_info: system_info,
    }
}
pub struct CreatePortResult {
    pub result: ErrorCode,
    pub server_port_handle: u32,
    pub client_port_handle: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn create_port(max_sessions: u32, is_light: u32, name: u64) -> CreatePortResult {
    let result: u32;
    let server_port_handle: u32;
    let client_port_handle: u32;
    asm ! ("svc 0x70" , in ("w2") max_sessions , in ("w3") is_light , in ("x4") name , lateout ("w0") result , lateout ("w1") server_port_handle , lateout ("w2") client_port_handle ,);
    CreatePortResult {
        result: ErrorCode::new_unchecked(result),
        server_port_handle: server_port_handle,
        client_port_handle: client_port_handle,
    }
}
pub struct ManageNamedPortResult {
    pub result: ErrorCode,
    pub server_port_handle: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn manage_named_port(name: *const u8, max_sessions: u32) -> ManageNamedPortResult {
    let result: u32;
    let server_port_handle: u32;
    asm ! ("svc 0x71" , in ("x1") name , in ("w2") max_sessions , lateout ("w0") result , lateout ("w1") server_port_handle ,);
    ManageNamedPortResult {
        result: ErrorCode::new_unchecked(result),
        server_port_handle: server_port_handle,
    }
}
pub struct ConnectToPortResult {
    pub result: ErrorCode,
    pub session_handle: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn connect_to_port(client_port_handle: u32) -> ConnectToPortResult {
    let result: u32;
    let session_handle: u32;
    asm ! ("svc 0x72" , in ("w1") client_port_handle , lateout ("w0") result , lateout ("w1") session_handle ,);
    ConnectToPortResult {
        result: ErrorCode::new_unchecked(result),
        session_handle: session_handle,
    }
}
pub struct SetProcessMemoryPermissionResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn set_process_memory_permission(
    process_handle: u32,
    addr: *const u8,
    size: u64,
    memory_permission: u32,
) -> SetProcessMemoryPermissionResult {
    let result: u32;
    asm ! ("svc 0x73" , in ("w0") process_handle , in ("x1") addr , in ("x2") size , in ("w3") memory_permission , lateout ("w0") result ,);
    SetProcessMemoryPermissionResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct MapProcessMemoryResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn map_process_memory(
    dst_address: *const u8,
    process_handle: u32,
    src_address: *const u8,
    size: u64,
) -> MapProcessMemoryResult {
    let result: u32;
    asm ! ("svc 0x74" , in ("x0") dst_address , in ("w1") process_handle , in ("x2") src_address , in ("x3") size , lateout ("w0") result ,);
    MapProcessMemoryResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct UnmapProcessMemoryResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn unmap_process_memory(
    dst_address: *const u8,
    process_handle: u32,
    src_address: *const u8,
    size: u64,
) -> UnmapProcessMemoryResult {
    let result: u32;
    asm ! ("svc 0x75" , in ("x0") dst_address , in ("w1") process_handle , in ("x2") src_address , in ("x3") size , lateout ("w0") result ,);
    UnmapProcessMemoryResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct QueryProcessMemoryResult {
    pub result: ErrorCode,
    pub page_info: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn query_process_memory(
    memory_info: u64,
    process_handle: u32,
    address: *const u8,
) -> QueryProcessMemoryResult {
    let result: u32;
    let page_info: u32;
    asm ! ("svc 0x76" , in ("x0") memory_info , in ("w2") process_handle , in ("x3") address , lateout ("w0") result , lateout ("w1") page_info ,);
    QueryProcessMemoryResult {
        result: ErrorCode::new_unchecked(result),
        page_info: page_info,
    }
}
pub struct MapProcessCodeMemoryResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn map_process_code_memory(
    process_handle: u32,
    dst_address: *const u8,
    src_address: *const u8,
    size: u64,
) -> MapProcessCodeMemoryResult {
    let result: u32;
    asm ! ("svc 0x77" , in ("w0") process_handle , in ("x1") dst_address , in ("x2") src_address , in ("x3") size , lateout ("w0") result ,);
    MapProcessCodeMemoryResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct UnmapProcessCodeMemoryResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn unmap_process_code_memory(
    process_handle: u32,
    dst_address: *const u8,
    src_address: *const u8,
    size: u64,
) -> UnmapProcessCodeMemoryResult {
    let result: u32;
    asm ! ("svc 0x78" , in ("w0") process_handle , in ("x1") dst_address , in ("x2") src_address , in ("x3") size , lateout ("w0") result ,);
    UnmapProcessCodeMemoryResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct CreateProcessResult {
    pub result: ErrorCode,
    pub process_handle: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn create_process(
    create_process_parameter: u64,
    capabilities: *const u8,
    capabilities_num: u64,
) -> CreateProcessResult {
    let result: u32;
    let process_handle: u32;
    asm ! ("svc 0x79" , in ("x1") create_process_parameter , in ("x2") capabilities , in ("x3") capabilities_num , lateout ("w0") result , lateout ("w1") process_handle ,);
    CreateProcessResult {
        result: ErrorCode::new_unchecked(result),
        process_handle: process_handle,
    }
}
pub struct StartProcessResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn start_process(
    process_handle: u32,
    main_thread_priority: u32,
    default_cpu_id: u32,
    main_thread_stack_size: u64,
) -> StartProcessResult {
    let result: u32;
    asm ! ("svc 0x7a" , in ("w0") process_handle , in ("w1") main_thread_priority , in ("w2") default_cpu_id , in ("x3") main_thread_stack_size , lateout ("w0") result ,);
    StartProcessResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct TerminateProcessResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn terminate_process(process_handle: u32) -> TerminateProcessResult {
    let result: u32;
    asm ! ("svc 0x7b" , in ("w0") process_handle , lateout ("w0") result ,);
    TerminateProcessResult {
        result: ErrorCode::new_unchecked(result),
    }
}
pub struct GetProcessInfoResult {
    pub result: ErrorCode,
    pub a_href_process_state_process_state_a: u64,
}
#[inline(always)]
#[must_use]
pub unsafe fn get_process_info(
    process_handle: u32,
    process_info_type: u32,
) -> GetProcessInfoResult {
    let result: u32;
    let a_href_process_state_process_state_a: u64;
    asm ! ("svc 0x7c" , in ("w0") process_handle , in ("w1") process_info_type , lateout ("w0") result , lateout ("x1") a_href_process_state_process_state_a ,);
    GetProcessInfoResult {
        result: ErrorCode::new_unchecked(result),
        a_href_process_state_process_state_a: a_href_process_state_process_state_a,
    }
}
pub struct CreateResourceLimitResult {
    pub result: ErrorCode,
    pub resource_limit_handle: u32,
}
#[inline(always)]
#[must_use]
pub unsafe fn create_resource_limit() -> CreateResourceLimitResult {
    let result: u32;
    let resource_limit_handle: u32;
    asm ! ("svc 0x7d" , lateout ("w0") result , lateout ("w1") resource_limit_handle ,);
    CreateResourceLimitResult {
        result: ErrorCode::new_unchecked(result),
        resource_limit_handle: resource_limit_handle,
    }
}
pub struct SetResourceLimitLimitValueResult {
    pub result: ErrorCode,
}
#[inline(always)]
#[must_use]
pub unsafe fn set_resource_limit_limit_value(
    resource_limit_handle: u32,
    limitable_resource: u32,
    limit_value: u64,
) -> SetResourceLimitLimitValueResult {
    let result: u32;
    asm ! ("svc 0x7e" , in ("w0") resource_limit_handle , in ("w1") limitable_resource , in ("x2") limit_value , lateout ("w0") result ,);
    SetResourceLimitLimitValueResult {
        result: ErrorCode::new_unchecked(result),
    }
}
